Les programmes à interface graphique décrit dans les chapitres précédents
sont prévus pour un ensemble fini d'expériences. Pour développer de
nouvelles expériences, on doit savoir comment accéder aux fonctionnalités
d'expEYES par logiciel. Les appels de fonctions importants pour communiquer
avec l'appareil sont donnés ci-dessous.

Établir la Connexion
""""""""""""""""""""

Pour accéder au matériel de EYES17, les modules Python pour \texttt{eyes17}
doivent être installés. Il sont censés se trouver dans un répertoire
nommé \texttt{eyes17}, qui pourrait être dans votre répertoire personnel
ou sur le \og Python PATH \fg{}. \textbf{Tout programme doit commencer
par les deux lignes suivantes~:}
\begin{lyxcode}
import~eyes17.eyes

p~=~eyes17.eyes.open()
\end{lyxcode}
La variable \texttt{p} est l'objet logiciel qui représente le matériel.

Les sections suivantes expliquent les appels de fonctions Python pour
accéder au matériel EYES17. Chaque appel de fonction est expliquer
avec un exemple d'utilisation.

set\_pv1(v), set\_pv2(v)
""""""""""""""""""

Règle la tension continue en PV1 et PV2. L'intervalle pour PV1 est
de -5 à 5. L'intervalle pour PV2 est de -3,3 à 3,3.
\begin{lyxcode}
print~p.set\_pv1(4)~

print~p.set\_pv2(2.1)
\end{lyxcode}
La valeur assignée à la sortie est affichée. Mesurer les tensions
avec un voltmètre.

get\_voltage(input)
"""""""""""""""""""

Renvoie la tension de l'entrée spécifiée.
\begin{lyxcode}
print~p.get\_voltage('A1')

print~p.get\_voltage('A2')

print~p.get\_voltage('A3')

print~p.get\_voltage('MIC')

print~p.get\_voltage('SEN')
\end{lyxcode}
Connecter PV1 à A1, et utiliser \texttt{set\_pv1()} et \texttt{get\_voltage('A1')}
ensemble. Cette fonction ajuste le calibre d'entrée par essais et
erreurs, selon la valeur du signal d'entrée.

get\_voltage\_time(input)
"""""""""""""""""""""""""

Renvoie un tuple, qui contient le timbre à date de l'ordinateur et
la tension à l'entrée spécifiée.
\begin{lyxcode}
print~p.get\_voltage\_time('A1')
\end{lyxcode}

get\_resistance()
""""""""""""""""""

Renvoie la valeur de la résistance connectée à SEN, qui devrait être
entre $100~\Omega$ et $100~k\Omega$ pour une précision raisonnable.
\begin{lyxcode}
print~p.get\_resistance()
\end{lyxcode}

get\_capacitance()
""""""""""""""""""

Renvoie la valeur de la capacité connectée en IN1 (fonctionne bien
dans le domaine du $pF$)
\begin{lyxcode}
print~p.get\_capacitance()
\end{lyxcode}

get\_version()
""""""""""""""

Renvoie la version du firmware.

\texttt{print p.get\_version()}

get\_temperature()
""""""""""""""""""

Renvoie la température du processeur à l'intérieur de EYES17
\begin{lyxcode}
print~p.get\_temperature()
\end{lyxcode}

set\_state(OUPUT=value)
"""""""""""""""""""""""

Règle l'état logique de la sortie OD1, SQ1, etc. Connecter OD1 à A1
et lancer~:
\begin{lyxcode}
p.set\_state(OD1=1)~

print~p.get\_voltage('A1')
\end{lyxcode}

set\_sine(frequency)
""""""""""""""""""""

Génère le signal sinusoïdal de la fréquence demandée sur WG (intervalle
de $5~Hz$ à $5000~Hz$). Toutes les valeurs intermédiaires ne sont
pas possibles, la fonction renvoie la valeur effectivement adoptée.
\begin{lyxcode}
print~p.set\_sine(502)
\end{lyxcode}
\texttt{502.00803}

set\_sine\_amp(amplitude)
"""""""""""""""""""""""""

L'amplitude peut être réglée à trois valeurs prédéfinies de tension
crête(0 pour avoir $80~mV$, 1 pour avoir $1~V$, 3 pour avoir $3~V$).
\begin{lyxcode}
p.set\_sine\_amp(2)
\end{lyxcode}
Règle l'amplitude à $3~V$ crête.

set\_sqr1(frequency)
""""""""""""""""""""

Règle la fréquence de la sortie SQ1 (intervalle de $4~Hz$ à $1~MHz$).
Toutes les valeurs intermédiaires ne sont pas possibles, la fonction
renvoie la valeur effectivement adoptée.
\begin{lyxcode}
print~p.set\_sqr1(15030)
\end{lyxcode}
\texttt{15030.53}

set\_sqr1\_slow(frequency)
""""""""""""""""""""""""""

Règle la fréquence de la sortie SQ1 (intervalle de $0,1~Hz$ à $1~MHz$).
Toutes les valeurs intermédiaires ne sont pas possibles, la fonction
renvoie la valeur effectivement adoptée. La résolution est fine mais
WG est désactivé quand on commande SQ1 de cette façon.
\begin{lyxcode}
print~p.set\_sqr1\_slow(0.5)
\end{lyxcode}

set\_sqr2(frequency)
""""""""""""""""""""

Similaire à set\_sqr1() mais SQ2 n'est pas disponible en même temps
que WG, une seule des deux sorties est utilisable à la fois.

set\_sqr1(frequency, dutyCyle)
""""""""""""""""""""""""""""""

Règle la fréquence de la sortie SQ1 (intervalle de $0,1~Hz$ à $1~MHz$).
Toutes les valeurs intermédiaires ne sont pas possibles, la fonction
renvoie la valeur effectivement adoptée.
\begin{lyxcode}
print~p.set\_sqr1(1000,~30)~~~~~~~~\#~1000~Hz,~rapport~cyclique~30\%
\end{lyxcode}

get\_freq(input)
""""""""""""""""

Mesure la fréquence d'un signal carré sur l'entrée, IN2 ou SEN. Connecter
SQ1 à IN2 et lancer le code~:
\begin{lyxcode}
p.set\_sqr1(1000)

print~p.get\_freq('IN2')
\end{lyxcode}

duty\_cycle(input)
""""""""""""""""""

Mesure le rapport cyclique d'un signal carré , IN2 ou SEN. Connecter
SQ1 à IN2 et lancer le code~:
\begin{lyxcode}
p.set\_sqr1(1000,~30)

print~p.duty\_cycle('IN2')
\end{lyxcode}

r2ftime(input1, input2)
"""""""""""""""""""""""

Mesure l'intervalle de temps entre un front montant sur input1 jusqu'à
un front descendant sur input2, les entrées peuvent éventuellement
être les mêmes. On peut l'utiliser pour tester un signal carré.

Connecter SQ1 à IN2 et lancer le code~:
\begin{lyxcode}
p.set\_sqr1(1000,~30)

print~p.r2ftime('IN2',~'IN2')
\end{lyxcode}
\texttt{0.0003}

Le signal carré à $1~kHz$ avec un rapport cyclique de 30\% a une
période de $1~ms$ et reste à l'état HAUT durant $0,3~ms$.

multi\_r2rtime(input, numCycles)
""""""""""""""""""""""""""""""""

Mesure l'intervalle de temps entre deux fronts montants de l'entrée
\texttt{input}. La durée entre deux fronts montants est un cycle.
On peut spécifier le nombre cycles à mesurer, la valeur par défaut
étant 1. Les valeurs autorisées sont 1,2,4,8,12,16,32 et 48. On peut
tester ça avec un signal carré.

Connecter SQ1 à IN2 et lancer le code~:
\begin{lyxcode}
p.set\_sqr1(1000)

print~p.multi\_r2rtime('IN2',~8)
\end{lyxcode}
\texttt{0.008}

select\_range(channel, range)
"""""""""""""""""""""""""""""

Les calibres pour A1 et A2 peuvent être réglés depuis $\pm0.5~V$
jusqu'à $\pm16~V$, à l'aide d'amplificateurs à gain programmable.
\begin{lyxcode}
p.select\_range('A1',~4)~~~~~~~~~\#~4~volt~maximum

p.select\_range('A1',~8)~~~~~~~~~\#~8~volt~maximum
\end{lyxcode}

capture1(Input, Number of samples, time interval)
"""""""""""""""""""""""""""""""""""""""""""""""""

Numérise l'entrée spécifiée. Le nombre d'échantillons peut aller jusqu'à
10000. La durée entre deux échantillons consécutifs est donnée en
microseconde (intervalle de $2$ à $1000~\lyxmathsym{\textmu}s$).
\begin{lyxcode}
print~p.capture1('A1',~5,~5)
\end{lyxcode}
affichera deux tableaux de dates et de tensions.

Quand on a besoin de créer un graphique de la tension de sortie pour
une meilleure compréhension, on peut le faire à l'aide du module \texttt{matplotlib},
importé grâce à l'interface \texttt{pylab}. Connecter WG à A1 à l'aide
d'un fil et lancer~:
\begin{lyxcode}
from~pylab~import~{*}

p.set\_sine\_amp(2)

p.set\_sine(1000)

p.select\_range('A1',~4)

t,v~=~p.capture1('A1',~300,~10)

plot(t,v)

show()
\end{lyxcode}
Le résultat de ce code est donné ci-dessous.
\begin{lyxcode}
\includegraphics[height=4cm]{pics/sine}
\end{lyxcode}

capture2(Number of samples, time interval)
""""""""""""""""""""""""""""""""""""""""""

Numérise les entrées A1 et A2 simultanément. Le nombre d'échantillons
peut aller jusqu'à 10000. La durée entre deux échantillons consécutifs
est donnée en microseconde (intervalle de $2$ à $1000~\lyxmathsym{\textmu}s$).

Connecter WG à A1, et une diode entre A1 et A2. Lancer le code ci-dessous~:
\begin{lyxcode}
from~pylab~import~{*}

p.set\_sine\_amp(2)

p.set\_sine(1000)

p.select\_range('A1',~4)

t,v,tt,vv~=~p.capture2(300,~10)

plot(t,v)

plot(tt,vv)

show()
\end{lyxcode}
Le résultat de ce code est donné ci-dessous.

\includegraphics[height=4cm]{pics/halfwave} \includegraphics[height=4cm]{pics/capture4}

capture4(Number of samples, time interval)
""""""""""""""""""""""""""""""""""""""""""

Numérise les entrées A1, A2, A3 et MIC simultanément. Le nombre d'échantillons
peut aller jusqu'à 10000. La durée entre deux échantillons consécutifs
est donnée en microseconde (intervalle de $2$ à $1000~\lyxmathsym{\textmu}s$).

Connecter WG à A3 et lancer le code donné ci-dessous. Le résultat
est montré ci-dessus.
\begin{lyxcode}
from~pylab~import~{*}

p.set\_sine\_amp(2)

p.set\_sine(1000)

p.select\_range('A1',~4)

res~=~p.capture4(300,~10)

plot(res{[}4{]},res{[}5{]})~~~~~~~~\#~A3

plot(res{[}6{]},res{[}7{]})~~~~~~~~\#~MIC

show()
\end{lyxcode}

set\_wave(frequency, wavetype)
""""""""""""""""""""""""""""""

Si le paramètre \texttt{wavetype} n'est pas spécifié, cela génère
un signal en utilisant la table d'onde existante. Si \texttt{wavetype}
est spécifié (\texttt{'sine'} ou \texttt{'tria'}), la table d'onde
correspondante est chargée.
\begin{lyxcode}
from~pylab~import~{*}

p.set\_wave(1000,~'sine')

p.set\_wave(100)~~~~~~~\#~fréq.~100Hz~avec~la~table~existante

x,y~=~p.capture1('A1',~500,50)

plot(x,y)

p.set\_wave(100,~'tria')~~\#~table~d'onde~triangulaire~et~100~Hz

x,y~=~p.capture1('A1',~500,50)

plot(x,y)

show()
\end{lyxcode}

load\_equation(function, span)
""""""""""""""""""""""""""""""

Crée la table d'onde en utilisant l'équation. Connecter WG à A1 et
lancer le code ci-dessous. Le résultat est montré plus bas.
\begin{lyxcode}
from~pylab~import~{*}

def~f1(x):

~~~~return~sin(x)~+~sin(3{*}x)/3~

p.load\_equation(f1,~{[}-pi,pi{]})

p.set\_wave(400)

x,y~=~p.capture1('A1',~500,10)

plot(x,y)

show()

\includegraphics[height=4cm]{pics/loadEquation}~~\includegraphics[height=4cm]{pics/loadTable}
\end{lyxcode}

load\_table(function, span)
"""""""""""""""""""""""""""

On peut aussi charger la table d'onde avec un tableau de 512 éléments.
Connecter WG à A1 et lancer le code ci-dessous. Après l'opération
de valeur absolue, la table commence par 256, puis descend jusqu'à
0 et enfin remonte jusqu'à 255, ce qui trace un signal triangulaire.
Le résultat dû à ce tableau est montré ci-dessus.
\begin{lyxcode}
from~pylab~import~{*}

x~=~arange(-256,~256)

x~=~abs(x)

p.load\_table(x)

p.set\_wave(400)

x,y~=~p.capture1('A1',~500,10)

plot(x,y)

show()
\end{lyxcode}

